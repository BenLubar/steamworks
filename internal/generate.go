// +build ignore

package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
)

func main() {
	apiData := readAPIData()
	callbacks := findCallbackDefs()
	addMissingCallbackStructs(&apiData, callbacks)
	writeFile(apiData, callbacks)
	if err := exec.Command("gofmt", "-r", "(x) -> x", "-w", "-s", "api.gen.go").Run(); err != nil {
		panic(err)
	}
	if err := exec.Command("go", "get", "golang.org/x/tools/cmd/stringer").Run(); err != nil {
		panic(err)
	}
	for _, e := range apiData.Enums {
		if err := exec.Command("stringer", "-type", e.Enumname, "-trimprefix", e.Enumname+"_").Run(); err != nil {
			panic(err)
		}
	}
}

func writeFile(apiData APIData, callbacks []*CallbackDef) {
	f, err := os.Create("api.gen.go")
	if err != nil {
		panic(err)
	}
	defer func() {
		if err := f.Close(); err != nil {
			panic(err)
		}
	}()
	cppf, err := os.Create("api.gen.cpp")
	if err != nil {
		panic(err)
	}
	defer func() {
		if err := cppf.Close(); err != nil {
			panic(err)
		}
	}()
	hf, err := os.Create("api.gen.h")
	if err != nil {
		panic(err)
	}
	defer func() {
		if err := hf.Close(); err != nil {
			panic(err)
		}
	}()
	writef := func(format string, args ...interface{}) {
		if _, err := fmt.Fprintf(f, format, args...); err != nil {
			panic(err)
		}
	}
	writecppf := func(format string, args ...interface{}) {
		if _, err := fmt.Fprintf(cppf, format, args...); err != nil {
			panic(err)
		}
	}
	writehf := func(format string, args ...interface{}) {
		if _, err := fmt.Fprintf(hf, format, args...); err != nil {
			panic(err)
		}
	}

	writecppf("// This code is generated by go generate. Do not edit manually.\n")
	writecppf("\n")
	writecppf("#include \"shim.h\"\n")
	writecppf("#include <steam/steam_api.h>\n")
	writecppf("#include <steam/steam_gameserver.h>\n")
	writecppf("\n")
	writecppf("typedef long long intp;\n")
	writecppf("\n")

	writehf("// This code is generated by go generate. Do not edit manually.\n")
	writehf("#pragma once\n")
	writehf("\n")

	writef("// This code is generated by go generate. Do not edit manually.\n")
	writef("//go:generate go run generate.go\n")
	writef("\n")
	writef("package internal\n")
	writef("\n")
	writef("/*\n")
	writef("#cgo CXXFLAGS: -std=c++11\n")
	writef("#cgo CPPFLAGS: -isystem ${SRCDIR}/include\n")
	writef("#cgo windows LDFLAGS: -L ${SRCDIR}/lib/windows\n")
	writef("#cgo linux,386 LDFLAGS: -L ${SRCDIR}/lib/linux32\n")
	writef("#cgo linux,amd64 LDFLAGS: -L ${SRCDIR}/lib/linux64\n")
	writef("#cgo linux windows,386 darwin LDFLAGS: -lsteam_api -lsdkencryptedappticket\n")
	writef("#cgo windows,amd64 LDFLAGS: -lsteam_api64 -lsdkencryptedappticket64\n")
	writef("\n")
	writef("#include \"api.gen.h\"\n")
	writehf("#include <stdbool.h>\n")
	writehf("#include <stdint.h>\n")
	writehf("typedef int CallbackID_t;\n")
	var exportTypes []string
	for _, t := range apiData.Typedefs {
		if strings.ContainsAny(t.Type, "[(") {
			continue
		}

		t.Typedef = strings.TrimSuffix(t.Typedef, "::SteamCallback_t")
		if t.Typedef == "ValvePackingSentinel_t" {
			continue
		}
		if strings.HasSuffix(t.Typedef, "_t") {
			var isCallback bool
			for _, c := range callbacks {
				if c.Name == t.Typedef {
					isCallback = true
					break
				}
			}
			if isCallback {
				continue
			}
			exportTypes = append(exportTypes, t.Typedef)
		} else if t.Typedef[0] >= 'A' && t.Typedef[0] <= 'Z' && strings.Contains(t.Type, "int") {
			exportTypes = append(exportTypes, t.Typedef)
		}

		if t.Typedef == "int8" || t.Typedef == "uint8" || t.Typedef == "int16" || t.Typedef == "uint16" || t.Typedef == "int32" || t.Typedef == "uint32" || t.Typedef == "int64" || t.Typedef == "uint64" {
			t.Type = t.Typedef + "_t"
		} else if t.Typedef == "lint64" {
			t.Type = "int64_t"
		} else if t.Typedef == "ulint64" {
			t.Type = "uint64_t"
		} else if t.Typedef == "intp" || t.Typedef == "uintp" {
			t.Type = t.Typedef + "tr_t"
		}

		writehf("typedef %s %s;\n", t.Type, t.Typedef)
	}
	writehf("typedef uint64 CSteamID;\n")
	writehf("typedef uint64 CGameID;\n")
	for _, e := range apiData.Enums {
		if i := strings.LastIndex(e.Enumname, "::"); i != -1 {
			e.Enumname = e.Enumname[i+len("::"):]
		}
		if e.Enumname == "AudioPlayback_Status" {
			e.Enumname = "EAudioPlayback"
		}
		writehf("typedef int %s;\n", e.Enumname)
	}
	for _, s := range apiData.Structs {
		if s.Struct[0] == 'C' && ((s.Struct[1] >= 'A' && s.Struct[1] <= 'Z') || strings.Contains(s.Struct, "::") || strings.HasSuffix(s.Struct, "ID")) {
			continue
		}
		writehf("typedef struct %s %s;\n", s.Struct, s.Struct)
	}
	writehf("#if defined(__linux__) || defined(__APPLE__)\n")
	writehf("#pragma pack(push, 4)\n")
	writehf("#else\n")
	writehf("#pragma pack(push, 8)\n")
	writehf("#endif\n")
	for _, s := range apiData.Structs {
		if s.Struct[0] == 'C' && ((s.Struct[1] >= 'A' && s.Struct[1] <= 'Z') || strings.Contains(s.Struct, "::") || strings.HasSuffix(s.Struct, "ID")) {
			continue
		}
		exportTypes = append(exportTypes, s.Struct)
		writehf("struct %s {\n", s.Struct)
		for _, f := range s.Fields {
			typeA, typeB := f.Fieldtype, ""
			for i := strings.IndexByte(typeA, ' '); i != -1; i = strings.IndexByte(typeA, ' ') {
				if typeA[:i] == "enum" || typeA[:i] == "class" {
					typeA = typeA[i+1:]
				} else if typeA[i+1] == '[' && typeA[len(typeA)-1] == ']' {
					typeA, typeB = typeA[:i], typeA[i+1:]
				} else {
					break
				}
			}
			if typeA == "_Bool" {
				typeA = "bool"
			}
			f.Fieldname = strings.Title(strings.TrimPrefix(f.Fieldname, "m_"))
			writehf("\t%s %s%s;\n", typeA, f.Fieldname, typeB)
		}
		writehf("};\n")
	}
	writehf("#pragma pack(pop)\n")
	writehf("extern bool SteamAPI_Init();\n")
	writehf("extern void SteamAPI_Shutdown();\n")
	writehf("extern bool SteamAPI_RestartAppIfNecessary(uint32 unOwnAppID);\n")
	writehf("extern void SteamAPI_ReleaseCurrentThreadMemory();\n")
	writehf("extern void SteamAPI_RunCallbacks();\n")
	writehf("extern intp GetSteamClient(); // wrapper\n")
	writecppf("extern \"C\" intp GetSteamClient() { return reinterpret_cast<intp>(SteamClient()); }\n")
	classes := []string{"SteamClient"}
	abstractClasses := []string{"ISteamMatchmakingPingResponse", "ISteamMatchmakingServerListResponse", "ISteamMatchmakingPingResponse", "ISteamMatchmakingPlayersResponse", "ISteamMatchmakingRulesResponse"}
	methodSuffixes := make(map[[2]string]int)
	for _, m := range apiData.Methods {
		if strings.HasPrefix(m.Returntype, "class I") && m.Classname == "ISteamClient" {
			name := strings.TrimSuffix(m.Returntype[len("class I"):], " *")
			classes = append(classes, name)
			writehf("extern intp Get%s(); // wrapper\n", name)
			writecppf("extern \"C\" intp Get%s() { return reinterpret_cast<intp>(%s()); }\n", name, name)
			m.skip = true
			continue
		}
		if m.Methodname == "SetWarningMessageHook" {
			m.skip = true
			continue
		}
		var isAbstract bool
		for _, a := range abstractClasses {
			if m.Classname == a {
				isAbstract = true
				break
			}
			for _, p := range m.Params {
				if p.Paramtype == "class "+a+" *" {
					isAbstract = true
					break
				}
			}
			if isAbstract {
				break
			}
		}
		if isAbstract {
			m.skip = true
			continue
		}
		m.Returntype = strings.TrimPrefix(m.Returntype, "class ")
		if m.Returntype == "AudioPlayback_Status" {
			m.Returntype = "EAudioPlayback"
		}
		if s, ok := methodSuffixes[[2]string{m.Classname, m.Methodname}]; !ok {
			methodSuffixes[[2]string{m.Classname, m.Methodname}] = 0
		} else {
			m.suffix = strconv.Itoa(s)
			methodSuffixes[[2]string{m.Classname, m.Methodname}] = s + 1
		}
		writehf("extern %s SteamAPI_%s_%s%v(intp instancePtr", m.Returntype, m.Classname, m.Methodname, m.suffix)
		for _, p := range m.Params {
			if *p != (struct {
				Paramname        string
				Out_struct       string
				Out_string       string
				Out_array_call   string
				Array_count      string
				Out_array_count  string
				Out_string_count string
				Buffer_count     string
				Out_buffer_count string
				Paramtype        string
				Desc             string
			}{Paramtype: p.Paramtype, Paramname: p.Paramname}) {
				// spew.Dump(p)
			}
			p.Paramtype = strings.TrimPrefix(p.Paramtype, "class ")
			p.Paramtype = strings.TrimPrefix(p.Paramtype, "ISteamHTMLSurface::")
			if p.Paramtype == "AudioPlayback_Status" {
				p.Paramtype = "EAudioPlayback"
			}
			writehf(", %s %s", p.Paramtype, p.Paramname)
		}
		writehf(");\n")
	}

	writef("*/\n")
	writef("import \"C\"\n")
	writef("import (\n")
	writef("\t\"unsafe\"\n")
	writef(")\n")

	writef("type (\n")
	for _, t := range exportTypes {
		writef("\t%s = C.%s\n", strings.TrimSuffix(t, "_t"), t)
	}
	writef("\tSteamID = C.CSteamID\n")
	writef("\tGameID = C.CGameID\n")
	writef(")\n")

	for _, e := range apiData.Enums {
		writef("\ntype %s int32\n\nconst (\n", e.Enumname)
		for _, v := range e.Values {
			v.Name = strings.TrimPrefix(v.Name, "k_")
			v.Name = strings.TrimPrefix(v.Name, "dc_")
			v.Name = strings.TrimPrefix(v.Name, "e")
			v.Name = strings.TrimPrefix(v.Name, e.Enumname)
			if e.Enumname[0] == 'E' {
				v.Name = strings.TrimPrefix(v.Name, e.Enumname[1:])
			}
			v.Name = strings.TrimPrefix(v.Name, "_")
			writef("\t%s_%s %s = %s\n", e.Enumname, v.Name, e.Enumname, v.Value)
		}
		writef(")\n")
	}
	writef("\nconst (\n")
	for _, c := range apiData.Consts {
		c.Constname = strings.TrimLeft(c.Constname, "abcdefghijklmnopqrstuvwxyz_")
		if c.Constname == "PersonaNameMax" {
			if c.Constval == "32" {
				c.Constname = "PersonaNameMaxRunes"
			} else {
				c.Constname = "PersonaNameMaxBytes"
			}
		}
		c.Consttype = strings.TrimSuffix(strings.TrimPrefix(c.Consttype, "const "), "_t")
		if c.Consttype == "int" {
			c.Consttype = ""
		}
		writef("\t%s %s = %s\n", c.Constname, c.Consttype, c.Constval)
	}
	writef(")\n")
	writef("func unsafeCString(s string) *C.char { return *(**C.char)(unsafe.Pointer(&s)) }\n")
	writef("func unsafeCBytes(b []byte) *C.char { return (*C.char)(unsafe.Pointer(&b[0])) }\n")
	writef("func SteamAPI_Init() bool { return bool(C.SteamAPI_Init()) }\n")
	writef("func SteamAPI_Shutdown() { C.SteamAPI_Shutdown() }\n")
	writef("func SteamAPI_RestartAppIfNecessary(unOwnAppID uint32) bool { return bool(C.SteamAPI_RestartAppIfNecessary(C.uint32(unOwnAppID))) }\n")
	writef("func SteamAPI_ReleaseCurrentThreadMemory() { C.SteamAPI_ReleaseCurrentThreadMemory() }\n")
	writef("func SteamAPI_RunCallbacks() { C.SteamAPI_RunCallbacks() }\n")
	for _, c := range classes {
		writef("func get%s() C.intp { return C.Get%s() }\n", c, c)
	}
	toGoType := func(ctype string) (string, string) {
		if ctype == "const char *" {
			return "", "string"
		}
		if ctype == "void" {
			return "", ""
		}

		ctype = strings.TrimPrefix(ctype, "const ")
		ctype = strings.TrimPrefix(ctype, "struct ")

		var ptr string
		for strings.HasSuffix(ctype, "**") {
			ptr += "*"
			ctype = ctype[:len(ctype)-1]
		}
		if strings.HasSuffix(ctype, " *") {
			ptr += "*"
			ctype = ctype[:len(ctype)-2]
		}
		if ctype == "void" {
			return ptr[1:], "unsafe.Pointer"
		}
		if strings.HasPrefix(ctype, "unsigned ") {
			ctype = "u" + ctype[len("unsigned "):]
		}

		switch ctype {
		case "int", "uint":
			return ptr, ctype + "32"
		case "ushort":
			return ptr, "uint16"
		case "float":
			return ptr, "float32"
		case "double":
			return ptr, "float64"
		case "bool", "int32", "int64", "uint8", "uint16", "uint32", "uint64":
			return ptr, ctype
		case "char":
			if ptr == "*" {
				return "", "[]byte"
			}
		case "CSteamID", "CGameID":
			return ptr, ctype[1:]
		}

		for _, et := range exportTypes {
			if et == ctype {
				return ptr, strings.TrimSuffix(ctype, "_t")
			}
		}

		for _, e := range apiData.Enums {
			if e.Enumname == ctype {
				return ptr, ctype
			}
		}

		return ptr, "C." + ctype
	}

	convertToC := func(ctype string) string {
		ptr, goType := toGoType(ctype)
		switch goType {
		case "float32":
			return "(" + ptr + "C.float)"
		case "float64":
			return "(" + ptr + "C.double)"
		case "bool", "int32", "int64", "uint8", "uint16", "uint32", "uint64":
			return "(" + ptr + "C." + goType + ")"
		case "string":
			return "unsafeCString"
		case "[]byte":
			return "unsafeCBytes"
		case "SteamID", "GameID":
			return "(" + ptr + "C.C" + goType + ")"
		}
		for _, e := range apiData.Enums {
			if e.Enumname == goType {
				return "(" + ptr + "C." + goType + ")"
			}
		}
		return ""
	}

	convertToGo := func(ctype string) string {
		ptr, goType := toGoType(ctype)
		switch goType {
		case "bool", "float32", "float64", "int32", "int64", "uint8", "uint16", "uint32", "uint64":
			return "(" + ptr + goType + ")"
		case "string":
			return "C.GoString"
		case "[]byte":
			return "C.GoBytes"
		case "SteamID", "GameID":
			return "(" + ptr + goType + ")"
		}
		for _, e := range apiData.Enums {
			if e.Enumname == goType {
				return "(" + ptr + goType + ")"
			}
		}
		return ""
	}

	for _, m := range apiData.Methods {
		if m.skip {
			continue
		}
		argTypes := make([]string, len(m.Params))
		for i, p := range m.Params {
			if p.Paramname == "type" {
				p.Paramname = "type_"
			}
			ptr, goType := toGoType(p.Paramtype)
			argTypes[i] = p.Paramname + " " + ptr + goType
		}
		retPtr, returnType := toGoType(m.Returntype)
		writef("func SteamAPI_%s_%s%s(%s) %s%s {\n\t", m.Classname, m.Methodname, m.suffix, strings.Join(argTypes, ", "), retPtr, returnType)
		if returnType != "" {
			writef("return %s(", convertToGo(m.Returntype))
		}
		writef("C.SteamAPI_%s_%s%s(get%s()", m.Classname, m.Methodname, m.suffix, m.Classname[1:])
		for _, p := range m.Params {
			writef(", %s(%s)", convertToC(p.Paramtype), p.Paramname)
		}
		if returnType != "" {
			writef(")")
		}
		writef(")\n}\n")
	}

	for _, c := range callbacks {
		writef("func RegisterCallback_%[1]s(f func(*%[1]s)) registeredCallback { return registerCallback(func(cdata unsafe.Pointer, _ uintptr, _ bool, _ SteamAPICall) { f((*%[1]s)(cdata)) }, unsafe.Sizeof(%[1]s{}), %[2]s + %[3]s, 0, false) }\n", strings.TrimSuffix(c.Name, "_t"), c.Category, c.Offset)
	}
}

type APIData struct {
	Typedefs []*struct {
		Typedef string
		Type    string
	}
	Enums []*struct {
		Enumname string
		Values   []*struct {
			Name  string
			Value string
		}
	}
	Consts []*struct {
		Constname string
		Consttype string
		Constval  string
	}
	Structs []*struct {
		Struct string
		Fields []*struct {
			Fieldname string
			Fieldtype string
		}
	}
	Methods []*struct {
		Classname  string
		Methodname string
		Callresult string
		Callback   string
		Returntype string
		Desc       string
		skip       bool
		suffix     string
		Params     []*struct {
			Paramname string
			// single space or omitted (?)
			Out_struct string
			// single space or omitted (?)
			Out_string string
			// two+ item comma-separated list of:
			// parameter holding length
			// method to call to get length
			// arguments to length method
			Out_array_call string
			// "length of array" parameter name
			Array_count string
			// "length of array" parameter name
			Out_array_count string
			// "length of string" parameter name
			Out_string_count string
			// "length of buffer" parameter name
			Buffer_count string
			// "length of buffer" parameter name
			Out_buffer_count string
			Paramtype        string
			Desc             string
		}
	}
}

func addMissingCallbackStructs(apiData *APIData, callbacks []*CallbackDef) {
	for _, c := range callbacks {
		var found bool
		for _, s := range apiData.Structs {
			if s.Struct == c.Name {
				found = true
				break
			}
		}
		if found {
			continue
		}
		fields := make([]*struct{ Fieldname, Fieldtype string }, len(c.Fields))
		for i, f := range c.Fields {
			var array string
			if f.Array != "" {
				array = " [" + f.Array + "]"
			}
			fields[i] = &struct {
				Fieldname, Fieldtype string
			}{
				Fieldname: f.Name,
				Fieldtype: f.Type + array,
			}
		}
		apiData.Structs = append(apiData.Structs, &struct {
			Struct string
			Fields []*struct{ Fieldname, Fieldtype string }
		}{
			Struct: c.Name,
			Fields: fields,
		})
	}
}

func readAPIData() (apiData APIData) {
	f, err := os.Open("include/steam/steam_api.json")
	if err != nil {
		panic(err)
	}
	defer func() {
		if err := f.Close(); err != nil {
			panic(err)
		}
	}()

	dec := json.NewDecoder(f)
	dec.DisallowUnknownFields()
	if err := dec.Decode(&apiData); err != nil {
		panic(err)
	}
	return
}

var headers = func() []string {
	names, err := filepath.Glob("include/steam/*.h")
	if err != nil {
		panic(err)
	}

	data := make([]string, len(names))
	for i, name := range names {
		b, err := ioutil.ReadFile(name)
		if err != nil {
			panic(err)
		}

		data[i] = strings.Replace(string(b), "\r", "", -1)
	}

	return data
}()

type CallbackDef struct {
	Comment string
	Name    string

	Category string
	Offset   string

	Fields []*CallbackField
}

type CallbackField struct {
	Comment string
	Name    string
	Type    string
	Array   string
}

func findCallbackDefs() []*CallbackDef {
	re1 := regexp.MustCompile(`(?m)^((?://.*\n)*)struct ([A-Za-z0-9_]+_t)\n\{ ?\n\tenum \{ k_iCallback = k_i([A-Za-z]+) \+ ([0-9]+) \};\n((?:\t.*\n)*)\};$`)
	re2 := regexp.MustCompile(`(?m)^((?://.*\n)*)DEFINE_CALLBACK\( ?([A-Za-z0-9_]+_t), k_i([A-Za-z]+) \+ ([0-9]+) ?\);?\n((?:[ \t]*CALLBACK_MEMBER\(.*\)[ \t]*(?://.*)?\n)*)END_DEFINE_CALLBACK_[0-9]+\(\)$`)

	var defs []*CallbackDef

	for _, h := range headers {
		for _, match := range re1.FindAllStringSubmatch(h, -1) {
			defs = append(defs, &CallbackDef{
				Comment:  match[1],
				Name:     match[2],
				Category: match[3],
				Offset:   match[4],
				Fields:   parseCallbackFields(match[5], parseCallbackField1),
			})
		}
		for _, match := range re2.FindAllStringSubmatch(h, -1) {
			defs = append(defs, &CallbackDef{
				Comment:  match[1],
				Name:     match[2],
				Category: match[3],
				Offset:   match[4],
				Fields:   parseCallbackFields(match[5], parseCallbackField2),
			})
		}
	}

	return defs
}

func parseCallbackFields(fields string, parse func(string) *CallbackField) []*CallbackField {
	var parsed []*CallbackField

	for {
		i := strings.IndexByte(fields, '\n')
		if i == -1 {
			return parsed
		}

		if line := strings.TrimSpace(fields[:i]); line != "" {
			if strings.HasPrefix(line, "enum ") && !strings.Contains(line, ";") {
				fields = fields[strings.IndexByte(fields, ';'):]
				i = strings.IndexByte(fields, '\n')
			} else if strings.HasPrefix(line, "//") {
				parsed[len(parsed)-1].Comment += "\n" + line
			} else {
				parsed = append(parsed, parse(line))
			}
		}
		fields = fields[i+1:]
	}
}

func parseCallbackField1(field string) *CallbackField {
	var comment string
	if fieldComment := strings.SplitN(field, "//", 2); len(fieldComment) == 2 {
		field = fieldComment[0]
		comment = strings.TrimSpace(fieldComment[1])
		if comment != "" {
			comment = " // " + comment
		}
	}
	field = strings.TrimSpace(field)
	field = strings.TrimSuffix(field, ";")
	var array string
	if fieldArray := strings.SplitN(field, "[", 2); len(fieldArray) == 2 {
		field = fieldArray[0]
		array = strings.TrimSpace(strings.TrimSuffix(fieldArray[1], "]"))
	}
	field = strings.TrimSpace(field)
	parts := strings.Fields(field)
	if len(parts) != 2 {
		if field == "{" {
			return nil
		}
		panic("TODO: parseCallbackField1: " + field)
	}

	return &CallbackField{
		Comment: comment,
		Name:    parts[1],
		Type:    parts[0],
		Array:   array,
	}
}
func parseCallbackField2(field string) *CallbackField {
	var comment string
	if fieldComment := strings.SplitN(field, "//", 2); len(fieldComment) == 2 {
		field = fieldComment[0]
		comment = strings.TrimSpace(fieldComment[1])
		if comment != "" {
			comment = " // " + comment
		}
	}
	field = strings.TrimSpace(field)
	field = strings.TrimPrefix(field, "CALLBACK_MEMBER(")
	field = strings.TrimSuffix(field, ")")
	field = strings.TrimSpace(field)
	parts := strings.Split(field, ",")
	if len(parts) != 3 {
		panic("TODO: parseCallbackField2: " + field)
	}
	return &CallbackField{
		Comment: comment,
		Name:    strings.TrimSpace(parts[2]),
		Type:    strings.TrimSpace(parts[1]),
	}
}
